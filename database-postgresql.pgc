/* $SchulteIT: database-postgresql.pgc 15235 2025-10-29 03:37:11Z schulte $ */
/* $JDTAUS$ */

/*
 * Copyright (c) 2018 - 2026 Christian Schulte <cs@schulte.it>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "config.h"
#include "database.h"
#include "math.h"
#include "proc.h"
#include "time.h"

#include <pgtypes_numeric.h>

#define DB_STATEMENT_MAX_LENGTH (size_t)2048

extern const struct Numeric *restrict const zero;
extern const struct Config *restrict const cnf;

static void db_warn(void) {
  werr("==== sqlca ====\n");
  werr("sqlcode: %ld\n", sqlca.sqlcode);
  werr("sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
  werr("sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
  werr("sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0], sqlca.sqlerrd[1],
       sqlca.sqlerrd[2], sqlca.sqlerrd[3], sqlca.sqlerrd[4], sqlca.sqlerrd[5]);
  werr("sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1],
       sqlca.sqlwarn[2], sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
       sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
  werr("sqlstate: %5s\n", sqlca.sqlstate);
  werr("===============\n");
}

static void db_fatal(void) {
  db_warn();
  fatal();
}

void *db_connect(const char *const cname) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = cname;
  const char *sql_tgt = String_chars(cnf->db_tgt);
  const char *sql_usr = String_chars(cnf->db_usr);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL CONNECT TO :sql_tgt AS :con USER :sql_usr;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
  EXEC SQL AT :con SET AUTOCOMMIT TO OFF;
  EXEC SQL AT :con SET TIMEZONE TO 'UTC';
  EXEC SQL AT :con PREPARE sample_create AS 
    INSERT INTO "SAMPLES" (
      "EXCHANGE_ID",
      "PRODUCT_ID",
      "NANOS",
      "PRICE"
    ) VALUES (
      $1, $2, $3, $4
    );

  EXEC SQL AT :con PREPARE id AS
    SELECT "INTERNAL_ID" FROM "IDENTIFIERS"
    WHERE "EXCHANGE_ID" = $1
      AND "EXTERNAL_ID" = $2;

  EXEC SQL AT :con PREPARE id_create AS
    INSERT INTO "IDENTIFIERS" (
      "EXCHANGE_ID",
      "EXTERNAL_ID",
      "INTERNAL_ID"
    ) VALUES (
      $1, $2, gen_random_uuid()
    ) RETURNING "INTERNAL_ID";

  EXEC SQL AT :con PREPARE plot_datapoint AS
    INSERT INTO "PLOTS_DATAPOINTS" (
      "PLOT_ID",
      "X",
      "Y"
    ) VALUES (
      $1, $2, $3
    );

  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return String_cnew(cname);
}

void db_disconnect(void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL DISCONNECT :con;
  // clang-format on
  String_delete(db);
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_begin(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_commit(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_rollback(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con ROLLBACK;;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_uuid(char *const uuid, const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  char *sql_uuid = uuid;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con SELECT gen_random_uuid() INTO :sql_uuid;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_symbol_to_id(char *const id, const void *const db,
                     const char *const e_id, const char *const symbol) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_symbol = symbol;
  char *sql_id = id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    EXECUTE id USING :sql_e_id, :sql_symbol INTO :sql_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return;
not_found:
  // clang-format off
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con
    EXECUTE id_create USING :sql_e_id, :sql_symbol INTO :sql_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_id_to_symbol(char *const symbol, const void *const db,
                     const char *const e_id, const char *const id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_id = id; 
  const char *sql_symbol = symbol;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    SELECT "EXTERNAL_ID" INTO :sql_symbol FROM "IDENTIFIERS"
    WHERE "EXCHANGE_ID" = :sql_e_id AND "INTERNAL_ID" = :sql_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_sample_create(const void *const db, const char *const e_id,
                      const char *const m_id, const struct Numeric *const nanos,
                      const struct Numeric *const price) {
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *sql_nanos = Numeric_db(nanos);
  const numeric *sql_price = Numeric_db(price);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
  EXEC SQL AT :con
    EXECUTE sample_create USING :sql_e_id, :sql_m_id, :sql_nanos, :sql_price;
  EXEC SQL AT :con COMMIT;
  // clang-format on
}

void db_samples_stddev(struct Numeric *const stddev, const void *const db,
                       const char *const e_id, const char *const m_id,
                       const struct Numeric *const wnanos) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *sql_wnanos = Numeric_db(wnanos);
  const numeric *sql_stddev = Numeric_db(stddev);
  int sql_stddev_ind[1] = {0};
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    WITH price_changes AS (
      SELECT
        "NANOS",
        "PRICE"
      FROM (
        SELECT
          "NANOS",
          "PRICE",
          lag("PRICE", 1) OVER (ORDER BY "NANOS") AS "PREVIOUS"
        FROM "SAMPLES"
        WHERE "EXCHANGE_ID" = :sql_e_id
          AND "PRODUCT_ID" = :sql_m_id
      ) sub
      WHERE "PRICE" <> "PREVIOUS" OR "PREVIOUS" IS NULL
    ),
    returns AS (
      SELECT
        "NANOS",
        "PRICE",
        ln("PRICE" / lag("PRICE", 1) OVER (ORDER BY "NANOS")) AS "RETURN"
      FROM price_changes
    ),
    stddev AS (
      SELECT
        "NANOS",
        "PRICE",
        stddev_samp("RETURN") OVER
          (ORDER BY "NANOS"
            RANGE BETWEEN :sql_wnanos PRECEDING AND CURRENT ROW) * 100
            AS "VOLATILITY_PERCENT"
      FROM returns
    )
    SELECT max("VOLATILITY_PERCENT") INTO :sql_stddev :sql_stddev_ind FROM stddev;
  EXEC SQL AT :con COMMIT;
  // clang-format on
  if (sql_stddev_ind[0] != 0)
    Numeric_copy_to(zero, stddev);
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_samples_open(const void *const db, const char *const e_id,
                     const char *const m_id,
                     const struct Numeric *const since) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *sql_since = Numeric_db(since);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
	EXEC SQL AT :con DECLARE samples_cursor CURSOR FOR
		SELECT "NANOS", "PRICE" 
    FROM "SAMPLES"
		WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id
			AND "NANOS" >= :sql_since
		ORDER BY "NANOS" ASC;

	EXEC SQL AT :con OPEN samples_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_samples_next(struct db_sample_rec *const sample, const void *const db) {
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  numeric *sql_nanos = Numeric_db(sample->nanos);
  numeric *sql_price = Numeric_db(sample->price);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
	EXEC SQL AT :con FETCH FROM samples_cursor INTO :sql_nanos, :sql_price;
  // clang-format on
  return true;
not_found:
  return false;
}

void db_samples_close(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con CLOSE samples_cursor;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_vacuum(const void *const db, const char *const fname) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  struct Numeric *now = Numeric_new();
  nanos_now(now);
  struct Numeric *before = Numeric_sub(now, cnf->wnanos_max);
  Numeric_delete(now);
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_tgt = String_chars(cnf->db_tgt);
  const char *sql_usr = String_chars(cnf->db_usr);
  char stmt[DB_STATEMENT_MAX_LENGTH] = {0};
  numeric *sql_before = Numeric_db(before);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  // clang-format on
  char *before_asc = Numeric_to_char(before, 0);
  const int r =
      snprintf(stmt, sizeof(stmt),
               "COPY(SELECT * FROM \"SAMPLES\" WHERE \"NANOS\" <= %s) TO "
               "PROGRAM 'xz - > %s.xz'",
               before_asc, fname);

  if (r < 0 || (size_t)r >= sizeof(stmt)) {
    werr("%s: %d: %s\n", __FILE__, __LINE__, __func__);
    fatal();
  }

  Numeric_char_free(before_asc);
  // clang-format off
  EXEC SQL AT :con PREPARE copy FROM :stmt;
  EXEC SQL AT :con EXECUTE copy;
  EXEC SQL AT :con DEALLOCATE PREPARE copy;
  EXEC SQL AT :con DELETE FROM "SAMPLES" WHERE "NANOS" <= :sql_before;
  EXEC SQL AT :con DELETE FROM "PLOTS";
  EXEC SQL AT :con COMMIT;
  EXEC SQL CONNECT TO :sql_tgt AS vfa USER :sql_usr;
  EXEC SQL AT vfa SET AUTOCOMMIT TO ON;
  EXEC SQL AT vfa SET TIMEZONE TO 'UTC';
  EXEC SQL AT vfa VACUUM FULL ANALYZE;
  EXEC SQL DISCONNECT vfa;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  Numeric_delete(before);
  return true;
}

bool db_stats(struct db_stats_rec *const stats, const void *const db,
              const char *const e_id, const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  numeric *bd_min = Numeric_db(stats->bd_min);
  int bd_min_ind[1] = {0};
  numeric *bd_max = Numeric_db(stats->bd_max);
  int bd_max_ind[1] = {0};
  numeric *bd_avg = Numeric_db(stats->bd_avg);
  int bd_avg_ind[1] = {0};
  numeric *sd_min = Numeric_db(stats->sd_min);
  int sd_min_ind[1] = {0};
  numeric *sd_max = Numeric_db(stats->sd_max);
  int sd_max_ind[1] = {0};
  numeric *sd_avg = Numeric_db(stats->sd_avg);
  int sd_avg_ind[1] = {0};
  numeric *bcl_factor = Numeric_db(stats->bcl_factor);
  numeric *scl_factor = Numeric_db(stats->scl_factor);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL WHENEVER NOT FOUND GO TO not_found;
	EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
	EXEC SQL AT :con
    SELECT "MIN_BUY_ORDER_DURATION_NANOS",
           "MAX_BUY_ORDER_DURATION_NANOS",
           "AVG_BUY_ORDER_DURATION_NANOS",
           "BUY_ORDER_CANCEL_FACTOR",
           "MIN_SELL_ORDER_DURATION_NANOS",
           "MAX_SELL_ORDER_DURATION_NANOS",
           "AVG_SELL_ORDER_DURATION_NANOS",
           "SELL_ORDER_CANCEL_FACTOR"
    INTO :bd_min :bd_min_ind,
         :bd_max :bd_max_ind,
         :bd_avg :bd_avg_ind,
         :bcl_factor,
         :sd_min :sd_min_ind,
         :sd_max :sd_max_ind,
         :sd_avg :sd_avg_ind,
         :scl_factor
		FROM "STATISTICS"
		WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  stats->bd_min_null = bd_min_ind[0] != 0 ? true : false;
  stats->bd_max_null = bd_max_ind[0] != 0 ? true : false;
  stats->bd_avg_null = bd_avg_ind[0] != 0 ? true : false;
  stats->sd_min_null = sd_min_ind[0] != 0 ? true : false;
  stats->sd_max_null = sd_max_ind[0] != 0 ? true : false;
  stats->sd_avg_null = sd_avg_ind[0] != 0 ? true : false;
  return true;
not_found:
  // clang-format off
  EXEC SQL AT :con ROLLBACK;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return false;
}

void db_stats_bcl_factor(const void *const db, const char *const e_id,
                         const char *const m_id, struct Numeric *const factor) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  numeric *sql_factor = Numeric_db(factor);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "STATISTICS"
    SET "BUY_ORDER_CANCEL_FACTOR" = :sql_factor
    WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id;
  EXEC SQL AT :con COMMIT;
not_found:
  EXEC SQL AT :con ROLLBACK;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_stats_scl_factor(const void *const db, const char *const e_id,
                         const char *const m_id, struct Numeric *const factor) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  numeric *sql_factor = Numeric_db(factor);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "STATISTICS"
    SET "SELL_ORDER_CANCEL_FACTOR" = :sql_factor
    WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id;
  EXEC SQL AT :con COMMIT;
not_found:
  EXEC SQL AT :con ROLLBACK;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_bfill(const void *const db, const char *const o_id,
                    const struct Numeric *const csecs,
                    const struct Numeric *const dsecs,
                    const struct Numeric *const b_filled,
                    const struct Numeric *const q_filled,
                    const struct Numeric *const q_fees, const bool t_done) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  const numeric *sql_csecs = Numeric_db(csecs);
  const numeric *sql_dsecs = dsecs != NULL ? Numeric_db(dsecs) : NULL;
  const numeric *sql_b_filled = Numeric_db(b_filled);
  const numeric *sql_q_filled = Numeric_db(q_filled);
  const numeric *sql_q_fees = Numeric_db(q_fees);
  const char *sql_status = t_done ? "DONE" : dsecs != NULL ? "BOUGHT" : NULL;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "BUY_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
      "BUY_ORDER_BASE_AMOUNT_FILLED" = :sql_b_filled,
      "BUY_ORDER_QUOTE_AMOUNT_FILLED" = :sql_q_filled,
      "BUY_ORDER_QUOTE_FEES" = :sql_q_fees
    WHERE "BUY_ORDER_ID" = :sql_o_id;
  // clang-format on
  if (t_done || dsecs != NULL) {
    // clang-format off
    EXEC SQL WHENEVER SQLWARNING CALL db_warn();
    EXEC SQL WHENEVER SQLERROR CALL db_fatal();
    EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
    EXEC SQL AT :con
      UPDATE "TRADES"
        SET "STATUS" = :sql_status,
          "BUY_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
          "BUY_ORDER_DONE_AT" = to_timestamp(:sql_dsecs)
      WHERE "BUY_ORDER_ID" = :sql_o_id;
    // clang-format on
  }
  // clang-format off
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_bopen(const void *const db, const char *const o_id,
                    const struct Numeric *const csecs,
                    const struct Numeric *const b_filled,
                    const struct Numeric *const q_filled,
                    const struct Numeric *const q_fees) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  const numeric *sql_csecs = Numeric_db(csecs);
  const numeric *sql_b_filled = Numeric_db(b_filled);
  const numeric *sql_q_filled = Numeric_db(q_filled);
  const numeric *sql_q_fees = Numeric_db(q_fees);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "BUY_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
      "BUY_ORDER_BASE_AMOUNT_FILLED" = :sql_b_filled,
      "BUY_ORDER_QUOTE_AMOUNT_FILLED" = :sql_q_filled,
      "BUY_ORDER_QUOTE_FEES" = :sql_q_fees
    WHERE "BUY_ORDER_ID" = :sql_o_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_sfill(const void *const db, const char *const o_id,
                    const struct Numeric *const csecs,
                    const struct Numeric *const dsecs,
                    const struct Numeric *const b_filled,
                    const struct Numeric *const q_filled,
                    const struct Numeric *const q_fees, const bool t_done) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  const numeric *sql_csecs = Numeric_db(csecs);
  const numeric *sql_dsecs = dsecs != NULL ? Numeric_db(dsecs) : NULL;
  const numeric *sql_b_filled = Numeric_db(b_filled);
  const numeric *sql_q_filled = Numeric_db(q_filled);
  const numeric *sql_q_fees = Numeric_db(q_fees);
  const char *sql_status = t_done ? "DONE" : dsecs != NULL ? "SOLD" : NULL;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "SELL_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
      "SELL_ORDER_BASE_AMOUNT_FILLED" = :sql_b_filled,
      "SELL_ORDER_QUOTE_AMOUNT_FILLED" = :sql_q_filled,
      "SELL_ORDER_QUOTE_FEES" = :sql_q_fees
    WHERE "SELL_ORDER_ID" = :sql_o_id;
  // clang-format on
  if (t_done || dsecs != NULL) {
    // clang-format off
    EXEC SQL WHENEVER SQLWARNING CALL db_warn();
    EXEC SQL WHENEVER SQLERROR CALL db_fatal();
    EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
    EXEC SQL AT :con
      UPDATE "TRADES"
        SET "STATUS" = :sql_status,
          "SELL_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
          "SELL_ORDER_DONE_AT" = to_timestamp(:sql_dsecs)
      WHERE "SELL_ORDER_ID" = :sql_o_id;
    // clang-format on
  }
  // clang-format off
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_sopen(const void *const db, const char *const o_id,
                    const struct Numeric *const csecs,
                    const struct Numeric *const b_filled,
                    const struct Numeric *const q_filled,
                    const struct Numeric *const q_fees) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  const numeric *sql_csecs = Numeric_db(csecs);
  const numeric *sql_b_filled = Numeric_db(b_filled);
  const numeric *sql_q_filled = Numeric_db(q_filled);
  const numeric *sql_q_fees = Numeric_db(q_fees);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "SELL_ORDER_CREATED_AT" = to_timestamp(:sql_csecs),
      "SELL_ORDER_BASE_AMOUNT_FILLED" = :sql_b_filled,
      "SELL_ORDER_QUOTE_AMOUNT_FILLED" = :sql_q_filled,
      "SELL_ORDER_QUOTE_FEES" = :sql_q_fees
    WHERE "SELL_ORDER_ID" = :sql_o_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trades_open(const void *const db, const char *const e_id,
                    const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  EXEC SQL AT :con DECLARE trades_cursor CURSOR FOR
    SELECT "TRADE_ID",
           "EXCHANGE_ID",
           "PRODUCT_ID",
           "BASE_CURRENCY_ID",
           "QUOTE_CURRENCY_ID",
           "STATUS",
           "BUY_ORDER_ID",
           extract(EPOCH FROM "BUY_ORDER_CREATED_AT") * 1000000000 AS "BUY_CNANOS",
           extract(EPOCH FROM "BUY_ORDER_DONE_AT") * 1000000000 AS "BUY_DNANOS",
           "BUY_ORDER_PRICE_ORDERED",
           "BUY_ORDER_BASE_AMOUNT_ORDERED",
           "BUY_ORDER_BASE_AMOUNT_FILLED",
           "BUY_ORDER_QUOTE_AMOUNT_FILLED",
           "BUY_ORDER_QUOTE_FEES",
           "SELL_ORDER_ID",
           extract(EPOCH FROM "SELL_ORDER_CREATED_AT") * 1000000000 AS "SELL_CNANOS",
           extract(EPOCH FROM "SELL_ORDER_DONE_AT") * 1000000000 AS "SELL_DNANOS",
           "SELL_ORDER_PRICE_ORDERED",
           "SELL_ORDER_BASE_AMOUNT_ORDERED",
           "SELL_ORDER_BASE_AMOUNT_FILLED",
           "SELL_ORDER_QUOTE_AMOUNT_FILLED",
           "SELL_ORDER_QUOTE_FEES"
    FROM "TRADES"
    WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id
      AND NOT ("STATUS" = 'DONE' OR "STATUS" = 'KILLED');
  EXEC SQL AT :con OPEN trades_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_trades_next(struct db_trade_rec *const trade, const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  char *id = trade->id;
  char *e_id = trade->e_id;
  char *m_id = trade->m_id;
  char *b_id = trade->b_id;
  char *q_id = trade->q_id;
  char *status = trade->status;
  char *bo_id = trade->bo_id;
  int bo_id_ind = -1;
  numeric *b_cnanos = Numeric_db(trade->b_cnanos);
  int b_cnanos_ind[1] = {0};
  numeric *b_dnanos = Numeric_db(trade->b_dnanos);
  int b_dnanos_ind[1] = {0};
  numeric *b_price = Numeric_db(trade->b_price);
  int b_price_ind[1] = {0};
  numeric *b_b_ordered = Numeric_db(trade->b_b_ordered);
  int b_b_ordered_ind[1] = {0};
  numeric *b_b_filled = Numeric_db(trade->b_b_filled);
  int b_b_filled_ind[1] = {0};
  numeric *b_q_fees = Numeric_db(trade->b_q_fees);
  int b_q_fees_ind[1] = {0};
  numeric *b_q_filled = Numeric_db(trade->b_q_filled);
  int b_q_filled_ind[1] = {0};
  char *so_id = trade->so_id;
  int so_id_ind = -1;
  numeric *s_cnanos = Numeric_db(trade->s_cnanos);
  int s_cnanos_ind[1] = {0};
  numeric *s_dnanos = Numeric_db(trade->s_dnanos);
  int s_dnanos_ind[1] = {0};
  numeric *s_price = Numeric_db(trade->s_price);
  int s_price_ind[1] = {0};
  numeric *s_b_ordered = Numeric_db(trade->s_b_ordered);
  int s_b_ordered_ind[1] = {0};
  numeric *s_b_filled = Numeric_db(trade->s_b_filled);
  int s_b_filled_ind[1] = {0};
  numeric *s_q_fees = Numeric_db(trade->s_q_fees);
  int s_q_fees_ind[1] = {0};
  numeric *s_q_filled = Numeric_db(trade->s_q_filled);
  int s_q_filled_ind[1] = {0};
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL AT :con FETCH FROM trades_cursor INTO
    :id, :e_id, :m_id, :b_id, :q_id, :status,
    :bo_id :bo_id_ind,
    :b_cnanos :b_cnanos_ind,
    :b_dnanos :b_dnanos_ind,
    :b_price :b_price_ind,
    :b_b_ordered :b_b_ordered_ind,
    :b_b_filled :b_b_filled_ind,
    :b_q_filled :b_q_filled_ind,
    :b_q_fees :b_q_fees_ind,
    :so_id :so_id_ind,
    :s_cnanos :s_cnanos_ind,
    :s_dnanos :s_dnanos_ind,
    :s_price :s_price_ind,
    :s_b_ordered :s_b_ordered_ind,
    :s_b_filled :s_b_filled_ind,
    :s_q_filled :s_q_filled_ind,
    :s_q_fees:s_q_fees_ind;
  // clang-format on
  trade->bo_id_null = bo_id_ind != 0 ? true : false;
  trade->b_cnanos_null = b_cnanos_ind[0] != 0 ? true : false;
  trade->b_dnanos_null = b_dnanos_ind[0] != 0 ? true : false;
  trade->b_price_null = b_price_ind[0] != 0 ? true : false;
  trade->b_b_ordered_null = b_b_ordered_ind[0] != 0 ? true : false;
  trade->b_b_filled_null = b_b_filled_ind[0] != 0 ? true : false;
  trade->b_q_filled_null = b_q_filled_ind[0] != 0 ? true : false;
  trade->b_q_fees_null = b_q_fees_ind[0] != 0 ? true : false;
  trade->so_id_null = so_id_ind != 0 ? true : false;
  trade->s_cnanos_null = s_cnanos_ind[0] != 0 ? true : false;
  trade->s_dnanos_null = s_dnanos_ind[0] != 0 ? true : false;
  trade->s_price_null = s_price_ind[0] != 0 ? true : false;
  trade->s_b_ordered_null = s_b_ordered_ind[0] != 0 ? true : false;
  trade->s_b_filled_null = s_b_filled_ind[0] != 0 ? true : false;
  trade->s_q_filled_null = s_q_filled_ind[0] != 0 ? true : false;
  trade->s_q_fees_null = s_q_fees_ind[0] != 0 ? true : false;
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return true;
not_found:
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return false;
}

void db_trades_close(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL AT :con CLOSE trades_cursor;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_bcreate(char *const t_id, const void *const db,
                      const char *const e_id, const char *const m_id,
                      const char *const b_id, const char *const q_id,
                      const char *const o_id,
                      const struct Numeric *const o_base,
                      const struct Numeric *const o_pr) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const char *sql_b_id = b_id;
  const char *sql_q_id = q_id;
  const char *sql_o_id = o_id;
  const numeric *sql_o_base = Numeric_db(o_base);
  const numeric *sql_o_pr = Numeric_db(o_pr);
  char *sql_t_id = t_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    INSERT INTO "TRADES"
      (
      "EXCHANGE_ID",
      "PRODUCT_ID",
      "BASE_CURRENCY_ID",
      "QUOTE_CURRENCY_ID",
      "STATUS",
      "BUY_ORDER_ID",
      "BUY_ORDER_BASE_AMOUNT_ORDERED",
      "BUY_ORDER_PRICE_ORDERED"
      )
    VALUES
      (
      :sql_e_id, :sql_m_id, :sql_b_id, :sql_q_id, 'BUYING', :sql_o_id,
      :sql_o_base, :sql_o_pr
      )
    RETURNING "TRADE_ID" INTO :sql_t_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_bupdate(const void *const db, const char *const t_id,
                      const char *const o_id,
                      const struct Numeric *const o_base,
                      const struct Numeric *const o_pr) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_t_id = t_id;
  const char *sql_o_id = o_id;
  const numeric *sql_o_base = Numeric_db(o_base);
  const numeric *sql_o_pr = Numeric_db(o_pr);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE
      "TRADES"
    SET
      "BUY_ORDER_ID" = :sql_o_id,
      "BUY_ORDER_BASE_AMOUNT_ORDERED" = :sql_o_base,
      "BUY_ORDER_PRICE_ORDERED" = :sql_o_pr,
      "STATUS" = 'BUYING'
    WHERE
      "TRADE_ID" = :sql_t_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_screate(char *const t_id, const void *const db,
                      const char *const e_id, const char *const m_id,
                      const char *const b_id, const char *const q_id,
                      const char *const o_id,
                      const struct Numeric *const o_base,
                      const struct Numeric *const o_pr) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const char *sql_b_id = b_id;
  const char *sql_q_id = q_id;
  const char *sql_o_id = o_id;
  const numeric *sql_o_base = Numeric_db(o_base);
  const numeric *sql_o_pr = Numeric_db(o_pr);
  char *sql_t_id = t_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    INSERT INTO "TRADES"
      (
      "EXCHANGE_ID",
      "PRODUCT_ID",
      "BASE_CURRENCY_ID",
      "QUOTE_CURRENCY_ID",
      "STATUS",
      "SELL_ORDER_ID",
      "SELL_ORDER_BASE_AMOUNT_ORDERED",
      "SELL_ORDER_PRICE_ORDERED"
      )
    VALUES
      (
      :sql_e_id, :sql_m_id, :sql_b_id, :sql_q_id, 'SELLING', :sql_o_id,
      :sql_o_base, :sql_o_pr
      )
    RETURNING "TRADE_ID" INTO :sql_t_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_supdate(const void *const db, const char *const t_id,
                      const char *const o_id,
                      const struct Numeric *const o_base,
                      const struct Numeric *const o_pr) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_t_id = t_id;
  const char *sql_o_id = o_id;
  const numeric *sql_o_base = Numeric_db(o_base);
  const numeric *sql_o_pr = Numeric_db(o_pr);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE
      "TRADES"
    SET
      "SELL_ORDER_ID" = :sql_o_id,
      "SELL_ORDER_BASE_AMOUNT_ORDERED" = :sql_o_base,
      "SELL_ORDER_PRICE_ORDERED" = :sql_o_pr,
      "STATUS" = 'SELLING'
    WHERE
      "TRADE_ID" = :sql_t_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_delete(const void *const db, const char *const t_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_t_id = t_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    DELETE FROM "TRADES" WHERE "TRADE_ID" = :sql_t_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_breset(const void *const db, const char *const o_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "BUY_ORDER_ID" = NULL,
      "BUY_ORDER_CREATED_AT" = NULL,
      "BUY_ORDER_DONE_AT" = NULL,
      "BUY_ORDER_PRICE_ORDERED" = NULL,
      "BUY_ORDER_BASE_AMOUNT_ORDERED" = NULL,
      "BUY_ORDER_BASE_AMOUNT_FILLED" = NULL,
      "BUY_ORDER_QUOTE_AMOUNT_FILLED" = NULL,
      "BUY_ORDER_QUOTE_FEES" = NULL,
      "STATUS" = 'SOLD'
    WHERE "BUY_ORDER_ID" = :sql_o_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trade_sreset(const void *const db, const char *const o_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_o_id = o_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TRADES" SET
      "SELL_ORDER_ID" = NULL,
      "SELL_ORDER_CREATED_AT" = NULL,
      "SELL_ORDER_DONE_AT" = NULL,
      "SELL_ORDER_PRICE_ORDERED" = NULL,
      "SELL_ORDER_BASE_AMOUNT_ORDERED" = NULL,
      "SELL_ORDER_BASE_AMOUNT_FILLED" = NULL,
      "SELL_ORDER_QUOTE_AMOUNT_FILLED" = NULL,
      "SELL_ORDER_QUOTE_FEES" = NULL,
      "STATUS" = 'BOUGHT'
    WHERE "SELL_ORDER_ID" = :sql_o_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trades_hold(struct db_balance_rec *balance, const void *const db,
                    const char *const e_id, const char *const q_id,
                    const char *const b_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_q_id = q_id;
  const char *sql_b_id = b_id;
  numeric *q = Numeric_db(balance->q);
  int q_ind[1] = {0};
  numeric *b = Numeric_db(balance->b);
  int b_ind[1] = {0};
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO q_not_found;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    SELECT sum("SELL_ORDER_QUOTE_AMOUNT_FILLED") INTO :q :q_ind
    FROM "TRADES"
    WHERE "EXCHANGE_ID" = :sql_e_id
      AND "QUOTE_CURRENCY_ID" = :sql_q_id
      AND ("STATUS" = 'SOLD' OR "STATUS" = 'SELLING');
  // clang-format on
q_not_found:
  if (q_ind[0] != 0)
    Numeric_copy_to(zero, balance->q);
  // clang-format off
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO b_not_found;
  EXEC SQL AT :con
    SELECT sum("BUY_ORDER_BASE_AMOUNT_FILLED") INTO :b :b_ind
    FROM "TRADES"
    WHERE "EXCHANGE_ID" = :sql_e_id
      AND "BASE_CURRENCY_ID" = :sql_b_id
      AND ("STATUS" = 'BOUGHT' OR "STATUS" = 'BUYING');
  EXEC SQL AT :con COMMIT;
  // clang-format on
b_not_found:
  if (b_ind[0] != 0)
    Numeric_copy_to(zero, balance->b);
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_plot_enanos(const void *const db, const char *const pl_id,
                       const struct Numeric *const enanos) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_id = pl_id;
  const numeric *sql_enanos = Numeric_db(enanos);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con
    UPDATE "PLOTS" SET "ENANOS" = :sql_enanos
    WHERE "PLOT_ID" = :sql_id;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_plot_datapoint(const void *const db, const char *const pl_id,
                          const struct Numeric *const x,
                          const struct Numeric *const y) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_id = pl_id;
  const numeric *sql_x = Numeric_db(x);
  const numeric *sql_y = Numeric_db(y);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con EXECUTE plot_datapoint USING :sql_id, :sql_x, :sql_y;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot(struct db_plot_rec *plot, const void *const db,
                      const char *const e_id, const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  char *id = plot->id;
  const numeric *snanos = Numeric_db(plot->snanos);
  const numeric *enanos = Numeric_db(plot->enanos);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL AT :con
    SELECT p."PLOT_ID", p."SNANOS", p."ENANOS" INTO :id, :snanos, :enanos
    FROM "TREND_PLOTS" t JOIN "PLOTS" p ON t."PLOT_ID" = p."PLOT_ID"
    WHERE t."EXCHANGE_ID" = :sql_e_id AND t."PRODUCT_ID" = :sql_m_id;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return;
not_found:
  // clang-format off
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con
    INSERT INTO "PLOTS"
      ("SNANOS", "ENANOS")
    VALUES
      (:snanos, :enanos)
    RETURNING "PLOT_ID", "SNANOS", "ENANOS" INTO :id, :snanos, :enanos;
  EXEC SQL AT :con
    INSERT INTO "PLOTS_DATAPOINTS"
      ("PLOT_ID", "X", "Y")
      SELECT :id, "NANOS", "PRICE"
      FROM "SAMPLES"
      WHERE "EXCHANGE_ID" = :sql_e_id
        AND "PRODUCT_ID" = :sql_m_id
        AND "NANOS" >= :snanos;
  EXEC SQL AT :con
    INSERT INTO "TREND_PLOTS"
      ("EXCHANGE_ID", "PRODUCT_ID", "PLOT_ID")
    VALUES
      ( :sql_e_id, :sql_m_id, :id);
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot_candle(const void *const db, const char *const e_id,
                             const char *const m_id,
                             const struct db_candle_rec *const candle) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *o = Numeric_db(candle->o);
  const numeric *h = Numeric_db(candle->h);
  const numeric *l = Numeric_db(candle->l);
  const numeric *c = Numeric_db(candle->c);
  const numeric *onanos = Numeric_db(candle->onanos);
  const numeric *hnanos = Numeric_db(candle->hnanos);
  const numeric *lnanos = Numeric_db(candle->lnanos);
  const numeric *cnanos = Numeric_db(candle->cnanos);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con
    INSERT INTO "TREND_CANDLES"
      ("EXCHANGE_ID", "PRODUCT_ID", "OPEN", "HIGH", "LOW", "CLOSE",
       "ONANOS", "HNANOS", "LNANOS", "CNANOS")
    VALUES
      (:sql_e_id, :sql_m_id, :o, :h, :l, :c, :onanos, :hnanos, :lnanos, :cnanos);
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot_marker(const void *const db, const char *const e_id,
                             const char *const m_id,
                             const struct Numeric *const x,
                             const struct Numeric *const y) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *sql_x = Numeric_db(x);
  const numeric *sql_y = Numeric_db(y);
  char sql_id[DATABASE_UUID_MAX_LENGTH + 1] = {0};
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con
    INSERT INTO "PLOTS"
      ("SNANOS", "ENANOS")
    VALUES
      (0, 0)
    RETURNING "PLOT_ID" INTO :sql_id;
  EXEC SQL AT :con
    INSERT INTO "PLOTS_DATAPOINTS"
      ("PLOT_ID", "X", "Y")
    VALUES
      (:sql_id, :sql_x, :sql_y);
  EXEC SQL AT :con
    INSERT INTO "TREND_MARKERS"
      ("EXCHANGE_ID", "PRODUCT_ID", "PLOT_ID")
    VALUES
      ( :sql_e_id, :sql_m_id, :sql_id);
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot_samples_open(const void *const db, const char *const e_id,
                                   const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL AT :con DECLARE trend_plot_cursor CURSOR FOR
		SELECT "X", "Y" 
    FROM "TREND_PLOTS" t
      JOIN "PLOTS" p ON t."PLOT_ID" = p."PLOT_ID"
      JOIN "PLOTS_DATAPOINTS" d ON p."PLOT_ID" = d."PLOT_ID"
		WHERE t."EXCHANGE_ID" = :sql_e_id
      AND t."PRODUCT_ID" = :sql_m_id
		ORDER BY "X" ASC;

	EXEC SQL AT :con OPEN trend_plot_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_tx_trend_plot_samples_next(
    struct db_datapoint_rec *restrict const point, const void *const db) {
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  numeric *x = Numeric_db(point->x);
  numeric *y = Numeric_db(point->y);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
	EXEC SQL AT :con FETCH FROM trend_plot_cursor INTO :x, :y;
  // clang-format on
  return true;
not_found:
  return false;
}

void db_tx_trend_plot_samples_close(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con CLOSE trend_plot_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot_candles_open(const void *const db, const char *const e_id,
                                   const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL AT :con DECLARE trend_plot_candles_cursor CURSOR FOR
		SELECT c."OPEN", c."HIGH", c."LOW", c."CLOSE",
      c."ONANOS", c."HNANOS", c."LNANOS", c."CNANOS"
    FROM "TREND_PLOTS" t
      JOIN "TREND_CANDLES" c ON t."EXCHANGE_ID" = c."EXCHANGE_ID"
                            AND t."PRODUCT_ID" = c."PRODUCT_ID"
		WHERE t."EXCHANGE_ID" = :sql_e_id
      AND t."PRODUCT_ID" = :sql_m_id
		ORDER BY "ONANOS" ASC;

	EXEC SQL AT :con OPEN trend_plot_candles_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_tx_trend_plot_candles_next(struct db_candle_rec *restrict const candle,
                                   const void *const db) {
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  numeric *o = Numeric_db(candle->o);
  numeric *h = Numeric_db(candle->h);
  numeric *l = Numeric_db(candle->l);
  numeric *c = Numeric_db(candle->c);
  numeric *onanos = Numeric_db(candle->onanos);
  numeric *hnanos = Numeric_db(candle->hnanos);
  numeric *lnanos = Numeric_db(candle->lnanos);
  numeric *cnanos = Numeric_db(candle->cnanos);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
	EXEC SQL AT :con
    FETCH FROM trend_plot_candles_cursor
    INTO :o, :h, :l, :c, :onanos, :hnanos, :lnanos, :cnanos;
  // clang-format on
  return true;
not_found:
  return false;
}

void db_tx_trend_plot_candles_close(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con CLOSE trend_plot_candles_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_tx_trend_plot_markers_open(const void *const db, const char *const e_id,
                                   const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
	EXEC SQL AT :con DECLARE trend_plot_markers_cursor CURSOR FOR
		SELECT d."X", d."Y"
    FROM "TREND_PLOTS" t
      JOIN "TREND_MARKERS" m ON t."EXCHANGE_ID" = m."EXCHANGE_ID"
                            AND t."PRODUCT_ID" = m."PRODUCT_ID"
      JOIN "PLOTS" p ON p."PLOT_ID" = m."PLOT_ID"
      JOIN "PLOTS_DATAPOINTS" d ON p."PLOT_ID" = d."PLOT_ID"
		WHERE t."EXCHANGE_ID" = :sql_e_id
      AND t."PRODUCT_ID" = :sql_m_id
		ORDER BY "X" ASC;

	EXEC SQL AT :con OPEN trend_plot_markers_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

bool db_tx_trend_plot_markers_next(
    struct db_datapoint_rec *restrict const point, const void *const db) {
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  numeric *x = Numeric_db(point->x);
  numeric *y = Numeric_db(point->y);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
	EXEC SQL AT :con
    FETCH FROM trend_plot_markers_cursor INTO :x, :y;
  // clang-format on
  return true;
not_found:
  return false;
}

void db_tx_trend_plot_markers_close(const void *const db) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con CLOSE trend_plot_markers_cursor;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trend_state(struct db_trend_state_rec *const state,
                    const void *const db, const char *const e_id,
                    const char *const m_id) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  numeric *lnanos = Numeric_db(state->cd_lnanos);
  numeric *langle = Numeric_db(state->cd_langle);
  char *ltrend = state->cd_ltrend;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND GO TO not_found;
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    SELECT "CANDLE_LAST_NANOS", "CANDLE_LAST_ANGLE", "CANDLE_LAST_TREND"
    INTO :lnanos, :langle, :ltrend
    FROM "TREND_STATES"
    WHERE "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
  return;
not_found:
  // clang-format off
  EXEC SQL AT :con
    INSERT INTO "TREND_STATES"
      ("EXCHANGE_ID", "PRODUCT_ID", "CANDLE_LAST_NANOS", "CANDLE_LAST_ANGLE",
       "CANDLE_LAST_TREND")
    VALUES
      (:sql_e_id, :sql_m_id, 0, 0, 'NONE')
    RETURNING
      "CANDLE_LAST_NANOS", "CANDLE_LAST_ANGLE", "CANDLE_LAST_TREND"
        INTO :lnanos, :langle, :ltrend;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}

void db_trend_state_update(const void *const db, const char *const e_id,
                           const char *const m_id,
                           const struct db_trend_state_rec *const state) {
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(1, stdout);
#endif
  // clang-format off
  EXEC SQL BEGIN DECLARE SECTION;
  const char *con = String_chars(db);
  const char *sql_e_id = e_id;
  const char *sql_m_id = m_id;
  const numeric *lnanos = Numeric_db(state->cd_lnanos);
  const numeric *langle = Numeric_db(state->cd_langle);
  const char *ltrend = state->cd_ltrend;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLWARNING CALL db_warn();
  EXEC SQL WHENEVER SQLERROR CALL db_fatal();
  EXEC SQL WHENEVER NOT FOUND CALL db_fatal();
  EXEC SQL AT :con BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
  EXEC SQL AT :con
    UPDATE "TREND_STATES"
      SET "CANDLE_LAST_NANOS" = :lnanos,
          "CANDLE_LAST_ANGLE" = :langle,
          "CANDLE_LAST_TREND" = :ltrend
    WHERE
      "EXCHANGE_ID" = :sql_e_id AND "PRODUCT_ID" = :sql_m_id;
  EXEC SQL AT :con COMMIT;
  // clang-format on
#ifdef ABAG_SQL_DEBUG
  ECPGdebug(0, stdout);
#endif
}
